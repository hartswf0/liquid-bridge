<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Geo-Harmonic Engine V3.0</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --color-accent: #88ddff;
            --color-bg: #050508;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--color-bg);
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            overflow: hidden;
        }

        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .tab-btn {
            transition: all 0.2s;
        }
        .tab-btn.active {
            background-color: rgba(136, 221, 255, 0.2);
            color: var(--color-accent);
            border-color: var(--color-accent);
        }

        #canvas-container {
            position: relative;
            width: 92vw;
            height: 92vw;
            max-width: 500px;
            max-height: 500px;
            background: #0a0a10;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5), 0 0 0 1px rgba(255,255,255,0.08);
            overflow: hidden;
            touch-action: none;
            margin: 0 auto;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #1a1a20;
            border-radius: 4px;
            outline: none;
            margin: 6px 0;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: var(--color-accent);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 0 3px #050508;
            transition: all 0.1s;
        }
        input[type="range"]::-webkit-slider-thumb:active {
            transform: scale(1.2);
            box-shadow: 0 0 0 4px #050508, 0 0 10px var(--color-accent);
        }

        .panel-title {
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-weight: 600;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 6px;
            margin-bottom: 10px;
            color: #ccc;
            font-size: 0.75rem;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            font-size: 0.6rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: #666;
            margin-bottom: 2px;
        }

        .vu-meter {
            height: 4px;
            background: #1a1a20;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 8px;
        }
        .vu-fill {
            height: 100%;
            background: linear-gradient(90deg, #88ddff, #ffdd88);
            width: 0%;
            transition: width 0.05s linear;
        }

        .btn {
            padding: 8px 6px;
            font-size: 0.65rem;
            border-radius: 6px;
            transition: all 0.15s;
        }
        .btn:active {
            transform: scale(0.95);
        }

        .mobile-panel {
            padding: 12px;
            border-radius: 12px;
        }
    </style>
<base target="_blank">
</head>
<body class="flex flex-col items-center justify-start h-screen p-3 gap-3">

    <!-- Header with Tabs -->
    <div class="w-full max-w-md flex gap-1 bg-[#0a0a10] rounded-lg p-1 border border-white/10">
        <button id="tab-topo" class="tab-btn active flex-1 py-2 px-3 text-xs uppercase tracking-wider rounded-md border border-transparent text-gray-400">
            Topography
        </button>
        <button id="tab-sonics" class="tab-btn flex-1 py-2 px-3 text-xs uppercase tracking-wider rounded-md border border-transparent text-gray-400">
            Sonics
        </button>
    </div>

    <!-- Canvas -->
    <div id="canvas-container" class="rounded-xl">
        <canvas id="topoCanvas"></canvas>
        
        <!-- Enhanced Readout -->
        <div id="readout" class="absolute top-3 right-3 text-right pointer-events-none">
            <div class="text-xs text-gray-500 uppercase tracking-wider">Flux</div>
            <div class="text-sm font-bold text-cyan-400" id="status-val">0.00%</div>
            <div class="vu-meter">
                <div class="vu-fill" id="vu-fill"></div>
            </div>
        </div>

        <!-- Start Overlay -->
        <div id="start-overlay" class="absolute inset-0 flex items-center justify-center transition-opacity duration-500 z-10 bg-black/80 backdrop-blur-sm">
            <div id="start-text" class="text-white text-xs tracking-widest uppercase border border-white/30 p-4 rounded-lg bg-black/50 cursor-pointer animate-pulse">
                Tap to Initiate
            </div>
        </div>
    </div>

    <!-- Control Panels Container -->
    <div class="w-full max-w-md flex-1 flex flex-col gap-3 overflow-hidden">
        
        <!-- Tab 1: Topography -->
        <div id="topo-tab" class="tab-content active bg-[#0a0a10] mobile-panel border border-white/10 shadow-lg">
            <div class="panel-title">Topography & Drainage</div>
            
            <div class="space-y-3">
                <div class="slider-group">
                    <div class="slider-header">
                        <span>Viscosity</span>
                        <span id="val-visc" class="text-cyan-400 font-mono">0.006</span>
                    </div>
                    <input type="range" id="visc-slider" min="0.001" max="0.02" step="0.001" value="0.006">
                </div>
                
                <div class="slider-group">
                    <div class="slider-header">
                        <span>Transfer</span>
                        <span id="val-transfer" class="text-cyan-400 font-mono">0.5</span>
                    </div>
                    <input type="range" id="transfer-slider" min="0.1" max="1.0" step="0.05" value="0.5">
                </div>
                
                <div class="slider-group">
                    <div class="slider-header">
                        <span>Isolines</span>
                        <span id="val-density" class="text-cyan-400 font-mono">12</span>
                    </div>
                    <input type="range" id="density-slider" min="6" max="24" step="2" value="12">
                </div>

                <div class="flex gap-2 pt-2">
                    <button class="btn flex-1 bg-white/5 hover:bg-white/10 text-gray-400 active" id="mode-wire">Wireframe</button>
                    <button class="btn flex-1 bg-white/5 hover:bg-white/10 text-gray-400" id="mode-fluid">Density</button>
                </div>

                <button class="btn w-full bg-red-800/20 hover:bg-red-800/40 text-red-300" id="btn-reset">Reset Field</button>
            </div>
        </div>

        <!-- Tab 2: Sonics -->
        <div id="sonics-tab" class="tab-content bg-[#0a0a10] mobile-panel border border-white/10 shadow-lg">
            <div class="panel-title">Harmonics & Echoes</div>
            
            <div class="space-y-3">
                <div class="slider-group">
                    <div class="slider-header">
                        <span>Harmony</span>
                    </div>
                    <select id="harmony-select" class="w-full bg-white/5 border border-white/10 text-white p-2 rounded-lg text-xs focus:ring-cyan-500 focus:border-cyan-500">
                        <option value="minor9">Minor 9th</option>
                        <option value="major7">Major 7th</option>
                        <option value="sus4">Suspended 4th</option>
                    </select>
                </div>
                
                <div class="slider-group">
                    <div class="slider-header">
                        <span>Reverb Mix</span>
                        <span id="val-wet" class="text-cyan-400 font-mono">50%</span>
                    </div>
                    <input type="range" id="reverb-wet-slider" min="0" max="100" step="1" value="50">
                </div>

                <div class="slider-group">
                    <div class="slider-header">
                        <span>Echo Delay</span>
                        <span id="val-delay-time" class="text-cyan-400 font-mono">0.50s</span>
                    </div>
                    <input type="range" id="delay-time-slider" min="0.1" max="1.0" step="0.01" value="0.5">
                </div>

                <div class="slider-group">
                    <div class="slider-header">
                        <span>Feedback</span>
                        <span id="val-feedback" class="text-cyan-400 font-mono">35%</span>
                    </div>
                    <input type="range" id="delay-feedback-slider" min="0" max="95" step="1" value="35">
                </div>

                <div class="pt-2">
                    <div class="text-xs text-gray-500 uppercase tracking-wider mb-1">Sound Field</div>
                    <div class="vu-meter">
                        <div class="vu-fill" id="vu-bottom"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- HAPTIC FEEDBACK UTIL ---
        function hapticClick(intensity = 10) {
            if ('vibrate' in navigator) {
                navigator.vibrate(intensity);
            }
        }

        function hapticSlide() {
            if ('vibrate' in navigator) {
                navigator.vibrate(5);
            }
        }

        // --- CORE CONFIGURATION ---
        const LOGICAL_SIZE = 24; // Increased for more density
        const RENDER_RES = 100;   // Higher render resolution
        const TICK_RATE = 16;

        const C4 = 261.63;
        const NOTE_FREQS = new Array(127).fill(0).map((_, i) => C4 * Math.pow(2, (i - 60) / 12));
        const CHORDS = {
            'minor9': [0, 3, 7, 10, 14],
            'major7': [0, 4, 7, 11, 14],
            'sus4':   [0, 5, 7, 10, 14]
        };

        let pressureGrid = new Float32Array(LOGICAL_SIZE * LOGICAL_SIZE).fill(0);
        let viscosityGrid = new Float32Array(LOGICAL_SIZE * LOGICAL_SIZE).fill(0);
        let highResGrid = new Float32Array(RENDER_RES * RENDER_RES).fill(0);
        
        let visualParams = {
            decayRate: 0.006,
            transferRate: 0.5,
            contourLevels: 12,
            renderMode: 'wire'
        };
        
        let audioParams = {
            harmony: 'minor9',
            reverbWet: 0.5,
            delayTime: 0.5,
            delayFeedback: 0.35,
            modDepth: 0.004,
        };

        let isPlaying = true;
        let lastTick = 0;
        let time = 0;
        let vuHistory = new Array(20).fill(0);

        const canvas = document.getElementById('topoCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');
        const startOverlay = document.getElementById('start-overlay');
        let width, height;

        let audioCtx, masterGain, pads = [];
        let verb, wetGain, dryGain, delayNode, feedbackGain;
        let isAudioInit = false;

        // --- AUDIO MODULE ---
        class CinematicPad {
            constructor(ctx, freq) {
                this.ctx = ctx;
                this.baseFreq = freq;
                
                this.osc1 = ctx.createOscillator();
                this.osc1.type = 'sawtooth';
                this.osc1.frequency.value = freq;
                
                this.osc2 = ctx.createOscillator();
                this.osc2.type = 'sawtooth';
                this.osc2.frequency.value = freq * 1.005;
                
                this.filter = ctx.createBiquadFilter();
                this.filter.type = 'lowpass';
                this.filter.Q.value = 2;
                
                this.gain = ctx.createGain();
                this.gain.gain.value = 0.001;
                this.pan = ctx.createStereoPanner();
                this.pan.pan.value = (Math.random() * 2) - 1;

                this.osc1.connect(this.filter);
                this.osc2.connect(this.filter);
                this.filter.connect(this.gain);
                this.gain.connect(this.pan);
                this.pan.connect(masterGain);
                
                this.osc1.start();
                this.osc2.start();
            }
            
            update(energy) {
                const now = this.ctx.currentTime;
                const targetGain = 0.05 + (energy * 0.12);
                this.gain.gain.setTargetAtTime(targetGain, now, 0.8);
                
                const targetFilterFreq = 100 + (energy * 3000);
                this.filter.frequency.setTargetAtTime(targetFilterFreq, now, 1.2);

                const modAmt = this.baseFreq * audioParams.modDepth;
                const freqMod = modAmt * Math.sin(now * 1.5);
                
                this.osc1.frequency.value = this.baseFreq + freqMod;
                this.osc2.frequency.value = (this.baseFreq * 1.005) + freqMod;
            }
            
            setFrequency(newFreq) {
                this.baseFreq = newFreq;
                this.osc1.frequency.setTargetAtTime(newFreq, this.ctx.currentTime, 0.5);
                this.osc2.frequency.setTargetAtTime(newFreq * 1.005, this.ctx.currentTime, 0.5);
            }
            
            stop() {
                const now = this.ctx.currentTime;
                this.gain.gain.cancelScheduledValues(now);
                this.gain.gain.setTargetAtTime(0, now, 0.5);
                this.osc1.stop(now + 1);
                this.osc2.stop(now + 1);
            }
        }
        
        function createReverbBuffer(time) {
            const rate = audioCtx.sampleRate;
            const len = rate * time;
            const buffer = audioCtx.createBuffer(2, len, rate);
            for(let i=0; i<len; i++) {
                const decay = Math.pow(1 - i/len, 3);
                buffer.getChannelData(0)[i] = (Math.random()*2-1)*decay*0.5;
                buffer.getChannelData(1)[i] = (Math.random()*2-1)*decay*0.5;
            }
            return buffer;
        }

        function updateReverb() {
            if (!isAudioInit) return;
            const mix = audioParams.reverbWet;
            wetGain.gain.setTargetAtTime(mix, audioCtx.currentTime, 0.05);
            dryGain.gain.setTargetAtTime(1.0 - mix, audioCtx.currentTime, 0.05);
        }

        function updateDelay() {
            if (!isAudioInit) return;
            delayNode.delayTime.setTargetAtTime(audioParams.delayTime, audioCtx.currentTime, 0.05);
            feedbackGain.gain.setTargetAtTime(audioParams.delayFeedback * 0.99, audioCtx.currentTime, 0.05);
        }

        function updateHarmony() {
            if (!isAudioInit) return;
            pads.forEach(p => p.stop());
            pads = [];
            const newFreqs = getChordFrequencies(audioParams.harmony);
            newFreqs.forEach(f => pads.push(new CinematicPad(audioCtx, f)));
            hapticClick(15);
        }

        function modulateAudio(totalEnergy) {
            if(!isAudioInit) return;
            const intensity = Math.min(totalEnergy / 5, 1.0);
            pads.forEach(p => p.update(intensity));
            
            const vuPercent = intensity * 100;
            document.getElementById('status-val').innerText = `${vuPercent.toFixed(1)}%`;
            document.getElementById('vu-fill').style.width = `${vuPercent}%`;
            
            vuHistory.shift();
            vuHistory.push(vuPercent);
            const avgVU = vuHistory.reduce((a,b) => a+b) / vuHistory.length;
            document.getElementById('vu-bottom').style.width = `${avgVU}%`;
        }

        async function initAudio() {
            if (isAudioInit) return;
            const AC = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AC();
            
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 1.0;

            delayNode = audioCtx.createDelay(1.0);
            feedbackGain = audioCtx.createGain();
            
            masterGain.connect(delayNode);
            delayNode.connect(feedbackGain);
            feedbackGain.connect(delayNode);
            
            verb = audioCtx.createConvolver();
            verb.buffer = createReverbBuffer(5.0);
            wetGain = audioCtx.createGain();
            dryGain = audioCtx.createGain();
            
            masterGain.connect(dryGain);
            dryGain.connect(audioCtx.destination);
            delayNode.connect(verb);
            verb.connect(wetGain);
            wetGain.connect(audioCtx.destination);

            updateReverb();
            updateDelay();
            updateHarmony();

            if(audioCtx.state === 'suspended') {
                try {
                    await audioCtx.resume();
                } catch(e) {
                    console.error("AudioContext resume failed:", e);
                }
            }

            isAudioInit = true;
            startOverlay.style.opacity = 0;
            setTimeout(() => startOverlay.style.display = 'none', 500);
            hapticClick(20);
        }

        // --- SIMULATION MODULE ---
        function getLIdx(x, y) { return y * LOGICAL_SIZE + x; }
        function getRIdx(x, y) { return y * RENDER_RES + x; }
        function getChordFrequencies(chordKey) {
            const intervals = CHORDS[chordKey];
            const baseNote = 36;
            const notes = [
                baseNote,              
                baseNote + intervals[0] + 12, 
                baseNote + intervals[1] + 12, 
                baseNote + intervals[2] + 12, 
                baseNote + intervals[3] + 12, 
                baseNote + intervals[4] + 12, 
                baseNote + intervals[0] + 24 
            ];
            return notes.map(n => NOTE_FREQS[n]);
        }

        function setCell(gx, gy, val) {
            if (gx >= 0 && gx < LOGICAL_SIZE && gy >= 0 && gy < LOGICAL_SIZE) {
                const idx = getLIdx(gx, gy);
                pressureGrid[idx] = Math.min(pressureGrid[idx] + 0.8 * val, 3.0);
            }
        }

        function tick() {
            time += 0.01;
            let totalEnergy = 0;

            const nextPressure = new Float32Array(pressureGrid);
            const nextVisc = new Float32Array(viscosityGrid);
            
            const DAMPING = 0.99;
            const ALPHA = 0.05;

            for (let y = 1; y < LOGICAL_SIZE - 1; y++) {
                for (let x = 1; x < LOGICAL_SIZE - 1; x++) {
                    const idx = getLIdx(x, y);
                    
                    let pressureSum = 0;
                    pressureSum += pressureGrid[getLIdx(x-1, y)] + pressureGrid[getLIdx(x+1, y)] + pressureGrid[getLIdx(x, y-1)] + pressureGrid[getLIdx(x, y+1)];
                    pressureSum += pressureGrid[getLIdx(x-1, y-1)] + pressureGrid[getLIdx(x+1, y-1)] + pressureGrid[getLIdx(x-1, y+1)] + pressureGrid[getLIdx(x+1, y+1)];
                    
                    nextPressure[idx] = (pressureGrid[idx] * 0.4) + (pressureSum * 0.075);
                    nextPressure[idx] *= DAMPING;

                    const transfer = (pressureGrid[idx] * visualParams.transferRate * ALPHA);
                    nextVisc[idx] = viscosityGrid[idx] + transfer;
                    nextVisc[idx] = Math.max(nextVisc[idx] - visualParams.decayRate, 0);

                    totalEnergy += nextVisc[idx];
                }
            }
            pressureGrid = nextPressure;
            viscosityGrid = nextVisc;

            const factor = (LOGICAL_SIZE - 1) / (RENDER_RES - 1);
            for (let y = 0; y < RENDER_RES; y++) {
                for (let x = 0; x < RENDER_RES; x++) {
                    const lx = x * factor;
                    const ly = y * factor;
                    const x0 = Math.floor(lx); const y0 = Math.floor(ly);
                    const x1 = Math.min(x0 + 1, LOGICAL_SIZE - 1);
                    const y1 = Math.min(y0 + 1, LOGICAL_SIZE - 1);
                    const tx = lx - x0; const ty = ly - y0;
                    
                    const v00 = viscosityGrid[getLIdx(x0, y0)];
                    const v10 = viscosityGrid[getLIdx(x1, y0)];
                    const v01 = viscosityGrid[getLIdx(x0, y1)];
                    const v11 = viscosityGrid[getLIdx(x1, y1)];
                    
                    const top = v00 * (1 - tx) + v10 * tx;
                    const bot = v01 * (1 - tx) + v11 * tx;
                    highResGrid[getRIdx(x, y)] = top * (1 - ty) + bot * ty;
                }
            }

            if (isAudioInit) {
                modulateAudio(totalEnergy);
            }
        }

        // --- RENDERING MODULE ---
        function draw() {
            ctx.clearRect(0, 0, width, height);
            drawBackgroundGrid();

            if (visualParams.renderMode === 'wire') {
                drawWireframe();
            } else {
                drawFluidDensity();
            }
        }

        function drawBackgroundGrid() {
            ctx.lineWidth = 1;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
            const step = width / 10;
            
            ctx.beginPath();
            for(let x=0; x<=width; x+=step) { ctx.moveTo(x, 0); ctx.lineTo(x, height); }
            for(let y=0; y<=height; y+=step) { ctx.moveTo(0, y); ctx.lineTo(width, y); }
            ctx.stroke();
        }

        function drawWireframe() {
            const cellW = width / (RENDER_RES - 1);
            const cellH = height / (RENDER_RES - 1);
            const levels = visualParams.contourLevels;

            for (let l = 1; l <= levels; l++) {
                const threshold = (l / levels) * 2.0;
                const hue = 180 + (l/levels) * 60;
                const alpha = 0.15 + (l/levels)*0.6;
                ctx.strokeStyle = `hsla(${hue}, 80%, 65%, ${alpha})`;
                ctx.lineWidth = 1.8 - (l/levels * 0.8);

                ctx.beginPath();
                for (let y = 0; y < RENDER_RES - 1; y++) {
                    for (let x = 0; x < RENDER_RES - 1; x++) {
                        const v0 = highResGrid[getRIdx(x, y)];
                        const v1 = highResGrid[getRIdx(x+1, y)];
                        const v2 = highResGrid[getRIdx(x+1, y+1)];
                        const v3 = highResGrid[getRIdx(x, y+1)];
                        
                        const bin = (v0>threshold?8:0) | (v1>threshold?4:0) | (v2>threshold?2:0) | (v3>threshold?1:0);
                        if (bin === 0 || bin === 15) continue;

                        const a = {x: x + (threshold-v0)/(v1-v0), y: y};
                        const b = {x: x + 1, y: y + (threshold-v1)/(v2-v1)};
                        const c = {x: x + (threshold-v3)/(v2-v3), y: y + 1};
                        const d = {x: x, y: y + (threshold-v0)/(v3-v0)};
                        
                        const sx = v => v.x * cellW;
                        const sy = v => v.y * cellH;

                        switch(bin) {
                            case 1: case 14: ctx.moveTo(sx(c), sy(c)); ctx.lineTo(sx(d), sy(d)); break;
                            case 2: case 13: ctx.moveTo(sx(b), sy(b)); ctx.lineTo(sx(c), sy(c)); break;
                            case 3: case 12: ctx.moveTo(sx(b), sy(b)); ctx.lineTo(sx(d), sy(d)); break;
                            case 4: case 11: ctx.moveTo(sx(a), sy(a)); ctx.lineTo(sx(b), sy(b)); break;
                            case 5: ctx.moveTo(sx(a), sy(a)); ctx.lineTo(sx(d), sy(d)); ctx.moveTo(sx(b), sy(b)); ctx.lineTo(sx(c), sy(c)); break;
                            case 6: case 9: ctx.moveTo(sx(a), sy(a)); ctx.lineTo(sx(c), sy(c)); break;
                            case 7: case 8: ctx.moveTo(sx(a), sy(a)); ctx.lineTo(sx(d), sy(d)); break;
                            case 10: ctx.moveTo(sx(a), sy(a)); ctx.lineTo(sx(b), sy(b)); ctx.moveTo(sx(c), sy(c)); ctx.lineTo(sx(d), sy(d)); break;
                        }
                    }
                }
                ctx.stroke();
            }
        }

        function drawFluidDensity() {
            const cellW = width / (RENDER_RES - 1);
            const cellH = height / (RENDER_RES - 1);
            
            for (let i = 0; i < highResGrid.length; i++) {
                const val = highResGrid[i];
                if (val < 0.01) continue;
                const x = (i % RENDER_RES) * cellW;
                const y = Math.floor(i / RENDER_RES) * cellH;
                
                const hue = 220 - Math.min(val * 12, 40);
                const alpha = Math.min(val * 0.5, 0.5);
                ctx.fillStyle = `hsla(${hue}, 80%, 65%, ${alpha})`;
                ctx.fillRect(x, y, cellW+1, cellH+1);
            }
        }

        function loop(timestamp) {
            if (isPlaying && timestamp - lastTick > TICK_RATE) { 
                tick();
                lastTick = timestamp;
            }
            draw();
            requestAnimationFrame(loop);
        }

        // --- INTERACTION & UI ---
        async function handleInteraction(e) {
            e.preventDefault();
            
            if (!isAudioInit) {
                await initAudio();
            }
            
            const rect = container.getBoundingClientRect();
            const touches = e.touches || [{clientX: e.clientX, clientY: e.clientY}];
            
            for (let i = 0; i < touches.length; i++) {
                const x = touches[i].clientX - rect.left;
                const y = touches[i].clientY - rect.top;
                
                const gx = Math.floor((x / width) * LOGICAL_SIZE);
                const gy = Math.floor((y / height) * LOGICAL_SIZE);
                
                setCell(gx, gy, 1);
                hapticClick(8);
            }
        }

        function setupEventListeners() {
            // Tab switching
            const tabTopo = document.getElementById('tab-topo');
            const tabSonics = document.getElementById('tab-sonics');
            const topoContent = document.getElementById('topo-tab');
            const sonicsContent = document.getElementById('sonics-tab');
            
            tabTopo.addEventListener('click', () => {
                topoContent.classList.add('active');
                sonicsContent.classList.remove('active');
                tabTopo.classList.add('active');
                tabSonics.classList.remove('active');
                hapticClick(12);
            });
            
            tabSonics.addEventListener('click', () => {
                sonicsContent.classList.add('active');
                topoContent.classList.remove('active');
                tabSonics.classList.add('active');
                tabTopo.classList.remove('active');
                hapticClick(12);
            });

            // Canvas interaction
            canvas.addEventListener('mousedown', e => { 
                handleInteraction(e); 
                canvas.addEventListener('mousemove', handleInteraction); 
            });
            window.addEventListener('mouseup', () => canvas.removeEventListener('mousemove', handleInteraction));
            canvas.addEventListener('touchstart', e => { 
                handleInteraction(e); 
                canvas.addEventListener('touchmove', handleInteraction, {passive: false});
            }, {passive: false});
            canvas.addEventListener('touchend', () => canvas.removeEventListener('touchmove', handleInteraction));
            
            startOverlay.addEventListener('click', handleInteraction, { once: true });

            // Sliders with haptic
            const sliders = [
                {id: 'density-slider', valId: 'val-density', key: 'contourLevels', type: 'int'},
                {id: 'visc-slider', valId: 'val-visc', key: 'decayRate', type: 'float', unit: ''},
                {id: 'transfer-slider', valId: 'val-transfer', key: 'transferRate', type: 'float'},
                {id: 'reverb-wet-slider', valId: 'val-wet', key: 'reverbWet', type: 'percent'},
                {id: 'delay-time-slider', valId: 'val-delay-time', key: 'delayTime', type: 'float', unit: 's'},
                {id: 'delay-feedback-slider', valId: 'val-feedback', key: 'delayFeedback', type: 'percent'}
            ];

            sliders.forEach(slider => {
                const element = document.getElementById(slider.id);
                const valElement = document.getElementById(slider.valId);
                
                element.addEventListener('input', e => {
                    let value;
                    if (slider.type === 'int') {
                        value = parseInt(e.target.value);
                    } else if (slider.type === 'float') {
                        value = parseFloat(e.target.value);
                    } else if (slider.type === 'percent') {
                        value = parseInt(e.target.value) / 100;
                    }
                    
                    if (slider.key === 'reverbWet' || slider.key === 'delayTime' || slider.key === 'delayFeedback') {
                        audioParams[slider.key] = value;
                    } else {
                        visualParams[slider.key] = value;
                    }
                    
                    let displayValue;
                    if (slider.type === 'float') {
                        displayValue = value.toFixed(3);
                    } else if (slider.type === 'percent') {
                        displayValue = `${parseInt(e.target.value)}%`;
                    } else if (slider.type === 'int') {
                        displayValue = value;
                    } else {
                        displayValue = e.target.value;
                    }
                    
                    if (slider.unit && slider.type !== 'percent') {
                        displayValue += slider.unit;
                    }
                    valElement.innerText = displayValue;
                    
                    if (slider.key === 'reverbWet') updateReverb();
                    if (slider.key === 'delayTime' || slider.key === 'delayFeedback') updateDelay();
                    
                    hapticSlide();
                });
            });

            // Visual mode buttons
            const btnWire = document.getElementById('mode-wire');
            const btnFluid = document.getElementById('mode-fluid');
            btnWire.addEventListener('click', () => { 
                visualParams.renderMode = 'wire'; 
                btnWire.classList.add('active'); 
                btnFluid.classList.remove('active');
                hapticClick(10);
            });
            btnFluid.addEventListener('click', () => { 
                visualParams.renderMode = 'fluid'; 
                btnFluid.classList.add('active'); 
                btnWire.classList.remove('active');
                hapticClick(10);
            });

            // Reset button
            document.getElementById('btn-reset').addEventListener('click', () => { 
                pressureGrid.fill(0);
                viscosityGrid.fill(0);
                hapticClick(20);
            });
            
            // Harmony selector
            document.getElementById('harmony-select').addEventListener('change', e => {
                audioParams.harmony = e.target.value;
                if (isAudioInit) { updateHarmony(); }
                hapticClick(15);
            });
        }

        // --- APP LIFECYCLE ---
        function initApp() {
            resize();
            setupEventListeners();
            setCell(LOGICAL_SIZE/2, LOGICAL_SIZE/2, 1);
            requestAnimationFrame(loop);
        }

        function resize() {
            const rect = container.getBoundingClientRect();
            width = rect.width;
            height = rect.height;
            const dpr = window.devicePixelRatio || 2;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            ctx.scale(dpr, dpr);
        }

        window.addEventListener('resize', resize);
        window.addEventListener('load', initApp);
    </script>
</body>
</html>
